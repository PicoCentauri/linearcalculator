from math import sqrt

import matplotlib.pyplot as plt
import numpy as np
from equistore import Labels, TensorBlock, TensorMap, slice_block


PARAMETER_KEYS_DICT = {"e": ["values"], "e_f": ["values", "positions"]}


def compute_power_spectrum(
    spherical_expansion_1: TensorMap, spherical_expansion_2: TensorMap = None
) -> TensorMap:
    """Generate the rotationally invariant power spectrum from spherical expansions.

    If two different sets of spherical expansions are provided, it is assumed that the
    invariants are generated by taking quadratic combinations of those. Otherwise,
    invariants are generated by combining coefficients of one spherical expansion.

    .. note::
        Currently only supports ``values`` and gradients with respect to ``positions``.

    :param spherical_expansion_1: first spherical expansions
    :param spherical_expansion_2: second spherical expansions
    :return: power spectrum containing the invariant values and gradients
    :raises NotImplementedError: If a spherical expansions contains a gradient with
        respect to an unknwon parameter.
    """
    # Make sure that the expansion coefficients have the correct set of keys associated
    # with 1-center expansion coefficients.
    key_names = ("spherical_harmonics_l", "species_center", "species_neighbor")
    if spherical_expansion_1.keys.names != key_names:
        raise ValueError(
            "key names of spherical_expansion_1 are "
            f"{spherical_expansion_1.keys.names} but have to be {key_names}"
        )

    if spherical_expansion_2 is None:
        use_same_spherical_expansions = True
        spherical_expansion_2 = spherical_expansion_1
    else:
        use_same_spherical_expansions = False
        if spherical_expansion_2.keys.names != key_names:
            raise ValueError(
                "key names of spherical_expansion_1 are "
                f"{spherical_expansion_1.keys.names} but have to be {key_names}"
            )

    blocks = []
    keys = []

    for (l1, sc1, sn1), block1 in spherical_expansion_1:
        # Find that block indices that have tge same spherical_harmonics_l and
        # species_center
        blocks2_idx = spherical_expansion_2.blocks_matching(
            spherical_harmonics_l=l1, species_center=sc1
        )
        for block2_idx in blocks2_idx:
            block2 = spherical_expansion_2.block(block2_idx)
            _, _, sn2 = spherical_expansion_2.keys[block2_idx]

            # Find common samples if samples are not the same
            if len(block1.samples) != len(block2.samples) or not np.all(
                block1.samples == block2.samples
            ):
                common_samples = Labels(
                    names=block1.samples.names,
                    values=np.asarray(
                        np.intersect1d(block1.samples, block2.samples).tolist()
                    ),
                )

                if len(common_samples) == 0:
                    continue

                spx1 = slice_block(block1, axis="samples", labels=common_samples)
                spx2 = slice_block(block2, axis="samples", labels=common_samples)
            else:
                spx1 = block1
                spx2 = block2

            # Avoid doubly computing / storing invariants that are
            # the same by symmetry of the neighbor species.
            # Example: Neighbor species (Na, Cl) produces the same
            # invariants as (Cl, Na), meaning that only one set
            # of invariants needs to be used.
            # If the two sets of expansion coefficients are different,
            # this does not apply
            if sn1 > sn2 and use_same_spherical_expansions:
                continue

            factor = 1 / sqrt(2 * l1 + 1)
            if sn1 != sn2:
                factor *= sqrt(2)

            properties = Labels(
                names=[f"{name}1" for name in spx1.properties.names]
                + [f"{name}2" for name in spx2.properties.names],
                values=np.array(
                    [
                        properties1.tolist() + properties2.tolist()
                        for properties1 in spx1.properties
                        for properties2 in spx2.properties
                    ],
                    dtype=np.int32,
                ),
            )

            # Compute the invariants by summation and store the results
            # operation: ima, imb -> iab
            data = factor * np.matmul(spx1.values.swapaxes(1, 2), spx2.values)

            block = TensorBlock(
                values=data.reshape(data.shape[0], -1),
                samples=spx1.samples,
                components=[],
                properties=properties,
            )

            n_properties = block.values.shape[1]

            for parameter in spx1.gradients_list():
                if parameter != "positions":
                    raise NotImplementedError(
                        "power spectrum currently only supports position gradients"
                    )

                gradient1 = spx1.gradient(parameter)
                gradient2 = spx2.gradient(parameter)

                if len(gradient1.samples) == 0 or len(gradient2.samples) == 0:
                    continue

                # The "sample" dimension in the power spectrum gradient samples do not
                # necessarily matches the "sample" dimension in the spherical expansion
                # gradient samples. We create new samples by creating a union between
                # the two gradient samples.
                gradients_samples_values = np.unique(
                    np.concatenate([gradient1.samples, gradient2.samples])
                )

                gradients_samples = Labels(
                    names=gradient1.samples.names,
                    values=np.asarray(gradients_samples_values.tolist()),
                )

                gradient_values = np.zeros(
                    [gradients_samples.shape[0], 3, n_properties]
                )

                # operation: ixma, imb -> ixab
                gradient1_values = factor * np.matmul(
                    gradient1.values.swapaxes(2, 3),
                    spx2.values[gradient1.samples["sample"], np.newaxis, :, :],
                )

                # Find correct indices of the 1st gradient values and fill the values in
                _, grad1_sample_idxs, _ = np.intersect1d(
                    gradients_samples, gradient1.samples, return_indices=True
                )
                gradient_values[grad1_sample_idxs] += gradient1_values.reshape(
                    gradient1.samples.shape[0], 3, -1
                )

                # operation: ima, ixmb -> ixab
                gradient2_values = factor * np.matmul(
                    spx1.values[gradient2.samples["sample"], np.newaxis, :, :].swapaxes(
                        2, 3
                    ),
                    gradient2.values,
                )

                # Find correct indices of the 2nd gradient values and fill the values in
                _, grad2_sample_idxs, _ = np.intersect1d(
                    gradients_samples, gradient2.samples, return_indices=True
                )
                gradient_values[grad2_sample_idxs] += gradient2_values.reshape(
                    gradient2.samples.shape[0], 3, -1
                )

                gradient = TensorBlock(
                    values=gradient_values,
                    samples=gradients_samples,
                    components=[gradient1.components[0]],
                    properties=properties,
                )
                block.add_gradient("positions", gradient)

            keys.append((l1, sc1, sn1, sn2))
            blocks.append(block)

    keys = Labels(
        names=["l", "species_center", "species_neighbor_1", "species_neighbor_2"],
        values=np.array(keys, dtype=np.int32),
    )

    return TensorMap(keys, blocks).keys_to_properties("l")


def plot_realization(realization, fname):
    tab10 = plt.rcParams["axes.prop_cycle"].by_key()["color"]

    fig, ax = plt.subplots(
        ncols=2,
        figsize=(12, 4),
        constrained_layout=True,
        sharey=True,
        sharex=True,
    )

    for i, key in enumerate(PARAMETER_KEYS_DICT.keys()):
        b = realization[key]
        color = tab10[i]

        # Energy subplot
        ax[0].plot(
            b.alpha_values,
            b.l_rmse_y_train,
            label=f"{key}: train, rmse_y_min = {b.rmse_y_train:.1e}",
            c=color,
            ls=":",
        )

        ax[0].plot(
            b.alpha_values,
            b.l_rmse_y_test,
            label=f"{key}: test, rmse_y_min = {b.rmse_y_test:.1e}",
            c=color,
        )

        ax[0].scatter(
            2 * [b.alpha],
            [b.rmse_y_train, b.rmse_y_test],
            c=color,
        )

        # Force subplot
        # For energy models (key=="e") we use the force per molecule
        if key == "e":
            l_rmse_f_train = b.l_rmse_f_train_mol
            l_rmse_f_test = b.l_rmse_f_test_mol
            rmse_f_train = b.rmse_f_train_mol
            rmse_f_test = b.rmse_f_test_mol
        else:
            l_rmse_f_train = b.l_rmse_f_train
            l_rmse_f_test = b.l_rmse_f_test
            rmse_f_train = b.rmse_f_train
            rmse_f_test = b.rmse_f_test

        ax[1].plot(
            b.alpha_values,
            l_rmse_f_train,
            label=f"{key}: train, RMSE_f_min = {b.rmse_f_train:.1e}",
            c=color,
            ls=":",
        )

        ax[1].plot(
            b.alpha_values,
            l_rmse_f_test,
            label=f"{key}: test, RMSE_f_min = {b.rmse_f_test:.1e}",
            c=color,
        )

        ax[1].scatter(
            2 * [b.alpha],
            [rmse_f_train, rmse_f_test],
            c=color,
            label=f"Î±_opt={b.alpha:.1e}",
        )

    for a in ax:
        a.axhline(1e2, c="gray", ls="dashed", zorder=-5)
        a.legend()
        a.set(xscale="log", yscale="log", xlabel="Î±")

    ax[0].set_ylabel(r"% $RMSE_\mathrm{energy}$")
    ax[1].set_ylabel(r"% $RMSE_\mathrm{force}$")

    if fname is not None:
        fig.savefig(fname, bbox_inches="tight")
